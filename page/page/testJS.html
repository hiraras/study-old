<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
			<script type="text/javascript" src="../../js/myJS.js"></script>
			
			<script type="text/javascript" src="../../js/jquery-1.11.2.min.js"></script>
			<script type="text/javascript" src="../../js/jquery-1.8.3.min.js"></script>
		
			<style type="text/css">
				.myDiv{
					border:2px solid blue;
					height:100px;
					width:80px;
				}
				#p{
					color:blue;
				}
			</style>
		<title></title>
	</head>
	<body onload="" onmousedown="whichElement(event)">
		<input type="button" value="弹出模式对话框"  onclick="showModalDialogFunc()"/>
		<div id="myDiv1" style="width: 200px;height: 200px;background: red;"></div>
		<button onclick="testPreventDefault(event)">点击测试preventDefalut()</button>
		<div class="myDiv">
			<p>aaaa</p>
			<span>bbbb</span>
		</div>
		<button onclick="testToggle()">点击</button>
		<div style="background-color: red;height:200px;width:250px;" id="div2"></div>
		<button onclick="hideTheDiv()">点击隐藏div</button>
		<button onclick="windowObjectFunc()">测试浏览器对象方法</button>
		<a name = "link1" href="javascript:windowObjectFunc()">testAHref1</a>
		<a name = "link2" href="javascript:console.log(111);console.log(222);">testAHref2</a>
		<a href="#link1">1111</a>
		<form action="" method="get">
			<input type="text" id="myInput" name="input1" />
		</form>
		<br />
		<img src="../img/1.jpg" alt="1.jpg" width="300px" height="240px" 
			align="center" style="padding: 30px;background-color: red;opacity: 0.5;filter: flipVe"/>
		<p id="myP">awefeawfawef</p>
		<a href="http://www.baidu.com" target="_blank">baidu</a>
		<a onclick="showHref(this)" href="../img/3.jpg" title="aaa" >aaa</a>
		
		<form action="" name="form1">
			<input type="text" onchange="changeText()" name="input1" />
			<input type="text" name="input2" />
			<input type="radio" name="myRadio" id="" value="man" checked onblur="lose()"/>男
			<!--
            	作者：kazilagui@163.com
            	时间：2017-07-19
            	描述：点击woman的radio使name为myRadio的元素值为woman
            -->
			<input type="radio" name="myRadio" id="" value="woman" onclick=myRadio.value="woman" />女
		</form>
		<button onclick="testCookies()">点击读取cookies</button>
		<!-- void运算符可以取消一个表达式的结果 -->
		<a href="Javascript:alert(void (1+2))">超链接</a>
		<div id="p">
			<div id="c">
				文字
			</div>
		</div>
		
	</body>
	<script>
		//注释的使用规范：
		/*
		1.应该边写代码边写注释,修改代码的同时修改相应的注释,保持注释和代码的一致性
		2.注释的内容要清楚明了,并且仅在必要的地方注释,注释量适中
		3.对代码的注释应放在其上方相邻位置,不可放在下面,但对于一些循环语句和条件语句,则可以放在循环语句条件语句之下第一行
		4.变量和常量的注释应放在上方相邻位置或者使用尾随注释
		5.如果可以定义全局变量,那么全局变量要有较详细的注释,包括其功能,取值范围,哪些函数可能使用它以及使用时的注意事项
		6.在每个源文件的头部要有必要的注释信息,包括文件名,版本号,作者,生成日期,功能描述(该文件与其他文件关系等)
		7.在每个方法的前面要有必要的注释信息,包括名称,功能描述,参数及返回值,调用关系等
		*/
		/*
		ECMAScript5严格模式:
		是ECMAScript5新增的功能,ECMAScript5虽然可以向后与ECMAScript3兼容,但是如果使用严格模式
		那些ECMAScript5"不再建议使用"的ECMAScript3语法功能会被全部进禁止，如果出现就会抛出异常
		使用严格模式可以捕捉到一些常见的代码错误,抛出异常,当一些相对来说不安全的操作执行时,使用严格模式可以阻止或者抛出异常
		要在全局范围内使用严格模式,只需在程序第一行定义下面的一行代码:"use strict";
		要在函数内使用严格模式,之需在函数体内第一行定义下面一行代码:"use strict";
		因为严格模式仅仅是使用一行文本字符串声明来实现,所以对于旧的不支持严格模式的浏览器来说不存在兼容性问题,因此可以大胆的使用!
		
		在严格模式下，必须使用var关键字显式的声明所有变量，而在一般情况下，会被认定为全局变量，
		对于作用域范围不清楚的变量，在严格模式下可避免发生混淆.
		在严格模式下删除全局变量，函数或者函数的参数将会被认为是语法错误.
		
		因为ECMAScript5新增的属性描述符Configurable默认值为true，因此默认不能删除一个不可配置对象的属性，
		不能修改一个只读对象的属性，也不能为不可扩展对象添加属性.
		严格模式下arguments属性是只读的，所以不能修改,如下会报错:
		arguments = [];
		在严格模式下，函数的参数列表中不能存在同名的参数:function myFunc(arg,arg){}
		在严格模式下，不能使用arguments.caller和arguments.callee
		在严格模式下，eval是保留的关键字，不能作为变量名，对象的属性，函数名及变量值,另外通过eval引入新的变量也不再有效
		在严格模式下，with语句被摒弃，它在执行时自身会引入一个上下文环境，造成程序心梗问题。如果使用会被认为是语法错误。
		此外，在严格模式下，不再支持八进制数字，因此严格模式下的010就是十进制的10，而不再等于八进制的8
		*/
		//<!--
		
		// -->
//		"use strict";
		//测试严格模式下删除全局变量是否报错的变量
		var abc = 60;
		//该函数测试使用严格模式的方式
		function testStrictMode(){
			"use strict";
			//没有使用var关键字声明变量，报错
//			strictMode = true;
//			console.log(strictMode);
			//严格模式下删除全局变量报错
//			delete abc;
			//严格模式下修改只读属性arguments，报错
//			arguments = [];
		}
		testStrictMode();
		function testToggle(){
			//以下两句代码改变了所有对象的原型的属性，导致toggle()方法的内部收到了影响，所以当使用：
			//$("#div2").toggle("slow");带参的形式时会报错
//			Object.prototype.first = "number one";
//			Object.prototype.second = "number two";
			$("#div2").toggle();
		}
		//读取cookies
		function testCookies(){
			alert(document.cookie);
			//arguments是函数内的固有变量，以数组的形式保存了调用方给该函数传入的所有参数 如：  haha(1,2,3); //--> [1, 2, 3] 
			//haha(1,2,'xixi','hehe'); //--> [1, 2, "xixi", "hehe"]
			console.log(arguments);
		}
		function changeText(){
			document.form1.input2.value = document.form1.input1.value.toUpperCase();
		}
		//失去焦点时触发，使radio元素变为未选中状态
		function lose(){
			document.forms[1].elements[2].checked = false;
		}
		//点击了网页上哪个元素，一些兼容性操作
		function whichElement(e){
			var target;
			//如果是IE浏览器则e=window.event，因为在IE浏览器中，对事件是通过window对象来调用的
			if(!e){
				var e = window.event;
			}
			if(e.target){
				target = e.target;
			}else{
				//适用于IE浏览器，将正在发生事件的节点返回给target变量
				if(e.srcElement){
					target = e.srcElement;
				}
			}
			if(target.nodeType == 3){
				target = target.parentNode;
			}
			var tName;
			tName = target.tagName;
			console.log("你点击了"+tName+"标签");
		}
		function testPreventDefault(event){
			event.preventDefault();
			console.log(event);
			console.log(1);
		}
		function showHref(msg){
			alert(typeof msg);
		}
		myFunction();
		function myFunction(){
			console.log("myFunction");
		}
		
		var name = "The Window";   
		var object = {   
	　　　 　name : "My Object",   
	　　　 　getNameFunc : function(){   
	　　　 　　　return function(){   
//					var name = 123;
//						console.log(this.name)
	　　　　 　　　　return this.name;   
	　　　　 　};   
	　　　 　},
		 getNameFunc2 : function(){
		 	 console.log(this.name);
		 }
		};   
		//先执行object里的getNameFunc方法，返回一个匿名函数，再加一个括号执行该匿名函数
		console.log(object.getNameFunc()()); //The Window
		object.getNameFunc2();//My Object
		//这种方式可以执行
		(function testFuncExe(){
			console.log("这是测试函数后面加括号能不能直接执行函数");
		})()
		
//		函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 
		function outer(){
			var a = 1;
			function inner(){
				a++;
				alert(a);
			}
			return inner;
		}
		var result = outer();
//		result();//alert(2);

		
		
		//测试typeof,同时可以看出，网页的onLoad函数在script标签内可执行的语句执行完成后执行
		console.log(typeof(1));
		
		//数据类型转换：
//		方法:String(),Number(),Boolean(),parseInt() 
//		parseInt()(从字符串第一个字符开始读取数字，直到遇到非数字字符时停止读取，将已读取的数字字符串转换为整数,
//		如果字符串以0x或0X开头则认定为16进制数值，不管指定哪一种进制，parseInt总是以十进制返回结果,如果字符串第一个字符就不是数字则返回NaN)
		console.log(parseInt("0x10"));
		
//		console.log(String(100+23));//输出123
		

//		自动类型转换：
		//当加号“+”作为二元操作符(binary)并且其中一个操作数为字符串类型时，另一个操作数将会被无条件转为字符串类型：（http://www.cnblogs.com/liuhe688/p/5918589.html）
		//对于基础类型，会直接转为与字面量相一致的字符串类型，而对于复合类型，会先试图调用对象的valueOf()方法，如果此方法返回值是引用类型，
		//则接着再调用其toString()方法，最后将返回值转为字符串类型。上面我们定义了一个对象，包含valueOf()和toString()方法，然后和一个空字符串进行运算，
		//可以看得出来，它是调用了valueOf()方法，然后我们重写此对象，将valueOf()移除，也就是不重写object的valueOf()方法，从最后的结果来看，
		//它最终是调用了toString()方法，然后将返回的数字类型与空字符串进行运算，最终得到一个字符串类型的值。
		//当字符串在逻辑环境中执行时，也会被转为布尔类型。空字符串会被转为false，其它字符串都会转为true
		//当undefined和null在逻辑环境中执行时，都被认为是false
		//当对象在逻辑环境中执行时，只要当前引用的对象不为空，都会被认为是true。如果一个对象的引用为null，根据上面的介绍，会被转换为false。
		//虽然使用typeof检测null为"object"，但它并不是严格意义上的对象类型，只是一个对象空引用的标识。
		//操作数在数字环境中参与运算时，会被转为相对应的数字类型值，其中的转换规则如下：
		//
		//i. 字符串类型转为数字(from string): 空字符串被转为0，非空字符串中，符合数字规则的会被转换为对应的数字，否则视为NaN
		//
		//ii. 布尔类型转为数字(from boolean): true被转为1，false被转为0
		//
		//iii. null被转为0，undefined被转为NaN
		//
		//iv. 对象类型转为数字(from object): valueOf()方法先试图被调用，如果调用返回的结果为基础类型，则再将其转为数字，如果返回结果不是基础类型，
		//则会再试图调用toString()方法，最后试图将返回结果转为数字，如果这个返回结果是基础类型，则会得到一个数字或NaN，如果不是基础类型，则会抛出一个异常
		//当加号“+”作为一元操作符(unary)时，引擎会试图将操作数转换为数字类型，如果转型失败，则会返回NaN
		//另外，我们可别忘了减号“-”操作符，当减号“-”作为一元操作符(unary negation)时，也会将操作数转换为数字，只不过转换的结果与上面相反，合法的数字都被转为负值。
		//
		//除加号“+”以外的其他二元操作符，都会将操作数转为数字，字符串也不例外(如果转型失败，则返回NaN继续参与运算)
		//除了上面的操作符之外，递增和递减操作符也会将操作数转为数字
		var foo = "5" ** "2";
		console.log("foo:"+typeof foo);//foo:Number
		console.log(typeof NaN);//NaN  type为number
		console.log("123\nabc");//\n这些转义字符是添加在一个字符串中，解释时进行相应的操作，这句代码输出为123换行abc
		//"5" ** "2" == 25
		console.log(21>>2);//输出5
		var a = 0;
		//document.write()输出内容的另一种格式
		document.write(a,"+++++++++",a++);
		
		switch(a){
			case 0:
				console.log(111);
				break;
			case 1:
				console.log(222);
				break;
			default:
				console.log(333);
				break;
		}
		for(var i=0;i<5;i++){
			console.log(i);
		}
		var myObject = {
			a: "a1",
			b: "b2",
			c: "c3",
			func:function(){
				console.log(this.a);
			}
		}
		for(x in myObject){
			console.log(x);//type 为string
		}
		//with可以在使用对象的属性和方法时省略对象名，如下，使用myObject的func()函数不需要写成myObject.func()
		with(myObject){
			func();
		}
		myObject.func();
		console.log("--------正则表达式----------");
		var s = "JavaScript is powerful and javascript is very easy!";
		//有g则匹配字符串中所有的满足条件的字符，否则，只匹配一次;i表示忽略大小写;m为多行匹配
		var regex = /javascript/ig;
		var myArr = s.match(regex);
		console.log("最近一次匹配的字符为："+RegExp.input);
		console.log("最近一次搜索的开始位置为："+RegExp.index);//在chrome浏览器中显示为undefined
		console.log("下次搜索的开始位置为："+RegExp.lastIndex);
		console.log("最近一次匹配的字符前面的子串为："+RegExp.leftContext);
		console.log("最近一次匹配的字符后面的子串为："+RegExp.rightContext);
		var replaceStr = s.replace(regex,"JAVASCRIPT");
		console.log("替换后字符串为："+replaceStr);
		
		var s2 = "JavaScript,C,C++,Java,Visual Basic";
		var regex2 = /,/;
		myArr2 = s2.split(",");
		for(x in myArr2){
			console.log(myArr2[x]);
		}
		
//			高级正则表达式:
		var name = 'fe7wf7fewf';
		var uw=name.replace(/\w+?\d\w/g, "a");
		console.log(uw);
		
		console.log("--------正则表达式----------");
		console.log("----------异常------------");
		try{
			var arr = null;
//				console.log(a.age);
			console.log(arr[0]);
		}catch(error){
			console.log(error.name+":"+error.message);
			
		}
		//finally即使没有错误也会执行
		finally{
			console.log(1);
		}
//			var str = "a";
//			var a = parseInt(str);
//			console.log(a);//NaN
		
		try{
			//抛出一个整形或字符串的数据error的值为抛出的数值
			throw "123";
//				抛出一个Error对象,括号中为错误信息
			throw new Error("发生了错误");
		}catch(error){
			console.log(error);
			
		}
		//finally即使没有错误也会执行
		finally{
			console.log(1);
		}
//			var num = Number("132");
//			console.log(typeof(num)+num);//number132
		//不能直接改变string的长度
//			var str = "aaaaaaa";
//			str.length = 10;
//			console.log(str.length);
		//为系统内置对象String添加一个name属性
//			var str = new String("abc");
//			str.name = "haha";
//			console.log(str+":"+str.name);//abc:haha
		var myObject = {
			name:"star",
			func:function(){
				console.log(this.name);
			}
		}
		function Student(name,age){
//				this.name = name;
			this.age = age;
//				Student.prototype = myObject;
//				Student.prototype.run = function(){
//					console.log("run");
//				};
//				console.log(Student);
		}
		//将Student的原型对象指向myObject，需要在构造函数外执行，在里面会失败
		Student.prototype = myObject;
		var stu1 = new Student("tom",15);
		var stu2 = new Student("ace",17);
//			for(var x in stu1){
//				console.log(stu1[x]);
//			}
		Student.prototype.name = "LuFei";
		//因为是指向地址，所以修改原型对象，原对象也会发生改变
		console.log(myObject.name);
		myObject.func();
		console.log(stu1.name);
//			stu2.run = "step";
//			console.log(stu2.run);

//一个对象的原型即为它的prototype属性,是由构造函数定义的,创建对象时,先创建了一个空的初始对向实例,然后用prototype去引用这个实例(也可以去引用其他实例)作为
//原型对象,然后javascript会自动的将prototype引用的实例作为创建的对象的原型对象,原型对象的属性和方法会被该构造函数所创建的所有对象所继承.
//注意：例如var str = new String(),此时str继承于String.prototype，但是并不是说String也继承与String.prototype
//			var str = "123456789";
			//substring的负数会被看作0
//			console.log(str.substring(3,1));//23
//			console.log(str);//123456789
//			//输出"123"
//			console.log(str.substring(-5,6));//123456
		//说明创建对象的三种方法适用于所有对象
//			var myBoolean = true;
//			console.log(myBoolean.valueOf());
		var myArr = new Array(1,2,3,4,5);
		//输出1,2,3,4,5
//			console.log(myArr.toString());
		//此时输出[3]
//			console.log(myArr.slice(2,-2));
//			console.log(myArr);
//			//shift、unshift、pop、push方法执行后数组就被改变了
//			console.log(myArr.push(6,7));
//			console.log(myArr);
//			console.log(Math.pow(Math.E,2));//等于Math.exp(2);
//			var myDate = new Date();
//			console.log(myDate.toLocaleString());
		//返回对象的原始值
//			console.log(typeof(myDate.valueOf()));//返回的是时间戳,type为number
		document.writeln("这是writeln（在文档中输出内容的同时添加一个换行符,实际应用中，在浏览器中输出换行符往往会被忽略，所以看不出来）");
		document.writeln("'test the function of writeln()'");
		
//			for(i=10;i<20;i++){
//				document.write(i+" ");
//			}
		
		console.log("---------浏览器对象---------");
//			console.log(window.name);
//			console.log(window);
		//setInterval第一个参数若要使用函数，则需填写函数名不需要加括号
//			setInterval(windowObjectFunc,1000);
		function windowObjectFunc(){
			console.log(11);
			
			resizeTo(200,150);
		}
		//windown.onload调用的函数后面加不加括号都行
		window.onload = windowObjectFunc();
		window.status = "ok";
		console.log(window.status);
		//只要超链接里有href属性就算一个
		console.log(document.links.length);
		//只要超链接里有name属性就算一个
		console.log(document.anchors.length);
		console.log(document.forms);
		//document的images属性，是保存了网页图片一些信息的数组，即便是设定了hidden="true"也会出现在数组
		console.log(document.images);
//			var myPrompt = prompt("点击以确定","111");
//			console.log(myPrompt);
		//document.write()可以输出图片（标签），你也可输出一张表格的一部分(如document.write("<table><tr>")
		//然后在另一句document.write()中输出document.write("</tr></table>")）这样也可以拼出一张表格
		document.write("<img src='../img/2.jpg' hspace='100px'/>")
		var myPEle = document.getElementById("myP");
		myPEle.innerHTML = "<b>agef</b>";
//			document.clear();
		console.log(history.length);
		//在指定大小的新窗口打开页面
//			window.open("http://www.baidu.com","","width=400,height=400");
		//替换当前页面地址为新的url地址
//			window.location = "http://www.baidu.com";
		console.log(screen);	
		
		<!--
		//当js代码被包括在<!---->中时，若浏览器支持js则忽略<!---->，若不支持js，代码会被注释而不会被显示到页面中
		console.log("测试网页的注释在支持javascript的浏览器的script标签里的作用");
		-->
		//可以直接通过id名来设置指定的元素属性，一下语句设定了id为myP的元素的字体颜色
		myP.style.color = "red";
		//获取文档中的所有节点
		var allTags = document.getElementsByTagName("*");
		console.log(allTags);
//			var myDiv = document.getElementsByClassName("myDiv")[0];
//			console.log(myDiv.getElementsByTagName("p").length);
//			//使用createAttribute()的方法  document.createAttribute(attributename)
//			var myAttr = document.createAttribute("style");
//			myAttr.value = "color:blue";
//			//不能使用myDiv.setAttribute(myAttr);
//			myDiv.setAttributeNode(myAttr);
//			
//			var myDiv_p = myDiv.getElementsByTagName("p")[0];
//			console.log(typeof(myDiv_p.childNodes[0]));//object
//			//使用了innerHTML后修改的是p标签内的文本节点
//			myDiv_p.innerHTML = "dddd";
//			//使用insertData()方法  先获取到文本节点（是个object对象）,然后执行方法insertData(位置,内容)
//			myDiv_p.childNodes[0].insertData(1,"cccc");
//			//使用deleteData()方法  先获取到文本节点（是个object对象）,然后执行方法deleteData(位置,长度)
//			myDiv_p.childNodes[0].deleteData(1,4);
////			myDiv_p = null;
//			//使用replaceData()方法  先获取到文本节点（是个object对象）,然后执行方法replaceData(位置,长度,新字符串)
//			myDiv_p.childNodes[0].replaceData(1,2,"ccc");
		
//			window.open("http://www.baidu.com","mywin","menubar=no,width=200,height=70,resizable=no");
		
		//cookies
		//存储为字符串，每次存储的信息用分号隔开了，如下存储后为user=abc;psw=123
		document.cookie = "user=abc";
		document.cookie = "psw=123";
		var myArr3 = document.cookie.split(";");
		for(var ele in myArr3){
//				console.log(myArr3[ele]);//name=Tom user=abc psw=123
		}
		//expires用来设定有效时间，比当前时间小则cookies无效
		var date = new Date();
		date.setDate(date.getDate()+30);
		document.cookie = encodeURI("name=Tom")+";expires="+date.toUTCString();
		//window.open(URL,window name,参数)
//			var win = window.open("http://www.baidu.com","","width=100,height=100,resizable=true");
//			setTimeout("go()",3000);
//			function go(){
//				win.resizeTo(500,500)
//			}
//			console.log(document.all);	
		//创建了一个date对象就会保存创建时的时间，而不是根据getTime()获取当前时间
		var date1 = new Date();
		console.log(date1.getTime());
//		setTimeout(testTime,3000);
		function testTime(){
			var date2 = new Date();
			console.log(date2.getTime());
		}
		//弹出添加到收藏夹窗口,第一个参数为地址，第二个为注释名
//			window.external.AddFavorite("","");
		//两种方式获得焦点
//			document.forms[0].input1.focus();
//			myInput.focus();
		var myArr4 = [1,2,3,4];
		console.log(myArr4);
		myArr4[0] = null;
		console.log(myArr4);//[null,2,3,4]
		myArr4[0] = undefined;
		console.log(myArr4);//[undefined,2,3,4]
		myArr4[0] = 1;
		delete myArr4[0];
		console.log(myArr4[0]);//undefined
		for(a in myArr4){
			console.log(myArr4[a]);
		}
		
		var output;
		var loop = 0;
		//break outer;语句跳出多层循环
		outer://outer:必须紧跟着包含着break语句最外层的大括号,如下面这句console.log语句会使程序报错,
//			因为break是流程控制语句，只能向下不能向上
//			console.log(1);
		for(var i=0;i<10;i++){
			for(var j=10;j>0;j--){
				for(var k=0;k<10;k++){
					if(i==j && j==k && j<2){
						output = i*j*k;
						break outer;
					}
					loop++;
				}
			}
		}
		console.log(output+":"+loop);
		//当调用函数没有传入参数是，形参为undefined（不会报错），当形参一样时，值取最后一个形参的值，当传入值多余形参数量，不会报错，小于则多出的为undefined
		function testFunc(n,n){
			var a = 1;
			console.log("testFunc:"+n);
			//arguments为保存形参的数组，即便定义函数时没有定义形参，但若调用时传递了参数，照样保存在arguments数组中!
			console.log(arguments)
//				console.log(this.testFunc.a);
		}
		testFunc();//undefined
		testFunc(1,2,3);//2
		
//			js中只有全局环境和函数环境,即除了函数内定义的值不能在外部调用外,其他例如for语句里面定义的变量都能在外部被调用
		for(var i=0;i<10;i++){
			var num = i;
		}
			
		console.log(num);//9
		
		var myObj = new Object();
		console.log(Object.prototype);
		myObj.func = function(a,b){
			alert(a*b);
		}
		
		var myObj2 = {
			myObj_var:1,
			func:function(){
				console.log(this.myObj_var);//1
			},
			innerObj:{
				innerObj_var:2,
				inner_func:function(){
					console.log(this);
				}
			}
		}
		myObj2.func();
		myObj2.innerObj.inner_func();
//			var myObj3 = {
//				myObj_var:2,
//				obj:myObj2
//			}
//			myObj3.obj.func();
		
		//this的应用:
//			1.在全局执行环境中使用this,表示Global对象,在浏览器中就是window对象
//			2.当在函数执行环境中使用this时,如果函数没有明显的作为非window对象的属性,而只是定义了函数,不管这个函数是不是定义在另一个
//			函数中,这个函数中的this仍然表示window对象.如果函数显式的作为一个非window对象的属性,那么函数中的this就代表这个对象.
//			例如:
			var o = new Object();
			o.func = function(){
				console.log(this === o);//true
				(function(){
					console.log(this === window);//函数内部的普通匿名函数，输出为true
				})()
			}
			
			o.func();
			var myStr = "abc";
			//注意：当一个函数为一个对象的属性，但调用时没有通过这个对象，这this不指向该对象,例如：
			var fn1 = o.func;
			fn1();//false和true
//			3.当通过new运算符来调用函数式,函数被当作一个构造函数,this指向构造函数创建出来的对象,例如用函数方法创建类中的this.a = a;
			//其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值。
//			4.当通过call或apply方法调用函数，函数指向call或apply中的对象
			



		//js中任何对象都继承于Object（js中所有事物都为对象，所有本地对象都继承自Object对象），所以对其进行拓展，所有对象都能继承
		//如下对Object原型对象进行了first属性的添加,然后myStr对象也继承了first属性,反之不能通过拓展String的原型对象来拓展Object对象
//		Object.prototype.first = "number one";
//		Object.prototype.second = "number two";
//			o.prototype.first = "aaa";//报错
//			console.log(o.prototype)//undefined
		//只会寻找原型链，而不会在Object上找
		Object.fourth = "aaa";
		console.log(myStr.first);//输出number one
		String.prototype.second = "n2";
		String.prototype.third = "n3";
		console.log(o.third);//undefined
		console.log(myStr.second);//n2
		console.log(myStr.first);//number one
		//另一种字符串使用方法
//			console.log("abc".charAt(1));//b
		function Build(){
			
		}
		var house = new Build();
		//通过构造函数创建的对象也隐式的继承Object.prototype对象
		console.log(house.first);
//			Object.aaa = 1;
		console.log(o.fourth);//undefined
		
		console.log(String.prototype)
		
		//用定义对象的方式定义一个函数
		var func1 = new Function("a","b","alert(\"func:\"+(this===myObj.func)+\",\"+(a-b))");
		var func2 = new Function("a","b","alert(\"func:\"+(this===window)+\",\"+(a+b))");
		//调用func1函数，并使其this指向myObj对象，后面接参数，
		//apply函数同样，不过参数是通过数组来传递
//			func1.call(myObj,5,3);
//			func1.apply(myObj.func,[5,3]);
		
		function MyClass(){
			this.a = 1;
			var obj = new Object();
			return obj;
		}
		var myObj4 = new MyClass();
		console.log(myObj4)
		
//			console.log(func1);
		var myStr2 = "hi~everyone!~hi";
		var reg = new RegExp("hi");
		var myStr3 = myStr2.replace(reg,"hello");
		console.log(myStr3);//hello~everyone!~hi，至匹配一次
		//表示字符串开头部位ab且字符串里面包含"ab",如下返回-1，表示找不到
		var reg2 = /\Bab/;
		var myStr4 = "cacb";
		console.log(myStr4.search(reg2));
		//style标签里的样式们
		console.log(document.styleSheets);
		//改变style标签里的第一个样式
		document.styleSheets[0].cssRules[0].style.color = "purple";
		//ie6环境下
//			document.styleSheets[0].rules[1].style.color = "purple";
		
		var c = document.getElementById("c");
		//输出空白内容，每个元素对象都有一个style对象属性，用来保存自己的样式，但它并不是及时更新的。
		//虽然c确实是蓝色的，但对于这种通过样式继承所实现的样式改变，style对象无法获取到最新的值.
		//需要用到运行时样式(注意：会使页面变卡，不能频繁的使用)
		console.log(c.style.color);
		console.log(window.getComputedStyle(c,null).color);//rgb(0,0,255)
		//ie环境下
//			console.log(c.currentStyle.color);
		
		//一个鼠标点击事件，由document开始逐层下降知道找到目标元素的过程叫事件流，在此过程中，中间的元素发生事件拦截，也就是事件捕捉（IE不支持事件捕捉）
		//然后会进行逆向的事件流，也叫事件冒泡，如果监听器没有进行事件捕捉，那么在事件冒泡时，监听器会被触发，有好处也有坏处，可以通过以下代码进行阻止
//			ele.addEventListener('click',function(e){
//				alert("B");
//				e.stopPropagation();
//			},1);
//			//IE环境下
//			ele.attachEvent('onclick',function(){
//				alert("B");
//				event.cancelBubble = true;
//			})
		
		//在文本框中敲击字母键会产生一个对应字母的输出，再点击表单中的“提交”按钮后页面就会转向新的URL地址。这些敲击或点击行为产生的结果
		//就是事件的默认行为，也可以通过代码进行阻止
		/*
		<input id="userName" type = "text" />
		<script>
			var userName = document.getElementById("userName");
			userName.onKeydown = function(e){
				var charCode = (e||event).keyCode;
				if(charCode<48 || charCode>59){
					alert("只能输入数字0-9");
					//阻止默认行为
					if(e)
						e.getPreventDefault();//标准方式
					else
						event.returnValue = false;//IE方式
				}
				
			}
		< /script>
		*/
//			var num = 0;
//			function testSetTimeInterval(){
//				
//				console.log(num);
//				
//			}
//			
//			var time = setInterval(testSetTimeInterval,5000);
		console.log(document.getElementsByClassName("myDiv")[0].style.cssText);
		
		
//			console.log((2.005-1.003)/20);
		
		
		Function.prototype.showColor = function(){
			console.log("blue");
			//指向的是调用它的Build
			console.log(this);
			this.prototype.ccc = function(){
				console.log("ccc");
			}
		}
		Build.showColor();//函数内的this为Build
		
		function Build(){
			this.color = "blue";
			Build.prototype.bbb = "abcsd";
			Build.prototype.showColor = function(){
				//这个this指向的是Build.prototype
				console.log(this.bbb);
			}
			
		}
		
		console.log(Function);
		console.log(Build.prototype);
		var house = new Build();
		house.ccc();
		console.log(house.prototype);
		var obj = new String();
//			obj.showColor()
//			house.aaa();
		String.prototype.ddd = function(){
			console.log(this);
			this.eee = 1;
		}
		var str2 = new String();
		str2.ddd();
//			String.ddd();
//			str2.ddd();
		console.log(str2.eee)
		
		var test = function(){
			
		}
//		test();
		test.age = "ss";
		console.log(test.age);//ss
//		name 属性返回一个函数的名称, 如果是匿名函数, 则返回空字符串（ES5）。
//		（ES6的name属性会返回实际的函数名）
		test.name = "ss";
		console.log(test.name);//test
		test.prototype.name = "ss";
		console.log(test.name);//test
		
		
		function Person(name, age) {
		    this.name = name;
		    this.age = age;
		    this.sayHi = function () {
		        console.log("hi, I am " + this.name);
		    }
		 
		}
		console.log(Object.prototype.__proto__);//null
		var nullProto = Object.create(null);
		console.log(nullProto);
//		Person.prototype = null;//当把Person.prototype设为null时，使用Person实例化的对象继承于null，没什么意义
		console.log(Person.prototype); //{}
		var me = new Person("ErumHuang", 22);
		console.log(me.__proto__);
		console.log(me.__proto__ === Person.prototype); //true
		console.log(Object.prototype === Function.prototype.__proto__);//true
		//假设Build、Function和Function.prototype为一家三代
//		Build.__proto__指向的是Function.prototype(我理解为__proto__属性指向的为对象所继承的对象)
//		Function.prototype.constructor指向的为Function
//		Build.constructor指向的也为Function
		console.log(Build.constructor === Function);//true
		console.log(Build.prototype===house.__proto__);//true
		console.log(house.constructor===Build.prototype.constructor);//true
		console.log(Object.getPrototypeOf(house)===house.__proto__);//true
		console.log(house.__proto__===house.constructor.prototype);//true
		//house.constructor.prototype通用访问器
		//house.__proto__非标准访问器，ie不支持
		//Object.getPrototypeOf(house)标准原型访问器
		console.log(typeof house.__proto__);//Object
		console.log(Object.__proto__ === Function.prototype);//true
		console.log(Function.__proto__ === Function.prototype);//true
		console.log(String.prototype.__proto__ === Object.prototype);//true
		console.log(String.__proto__ === Object);//false
		console.log(Build.__proto__ === Function.prototype);//true
		console.log(myObject.__proto__ === Function.__proto__.__proto__);//true
		console.log(Object.prototype === Object.__proto__.__proto__);//true
		console.log(Build.prototype === Build.__proto__);//false
		Function.prototype.height = 60;
		console.log(Object.height);//60
		console.log(Function.height);//60
		console.log(Object.constructor === Function);//true
		
		console.log(Function.prototype.constructor === Function);//true
		console.log((new Function()).constructor === Function);//true
		console.log(Build.prototype.constructor === Build);//true
		console.log(Build.prototype.constructor===Object);//false
		console.log((new Build()).constructor === Build);//true
		
		console.log(Build.prototype.__proto__ === Object.prototype);//true
		console.log(Object.prototype.__proto__);//null
		
		//模拟instanceof的运算过程，即A instanceof B时，若A.__proto__这条隐式原型链有一个等于B.prototype则返回true
		function _instanceof(A, B) {
		    var O = B.prototype;// 取B的显示原型
		    A = A.__proto__;// 取A的隐式原型
		    while (true) {
		        //Object.prototype.__proto__ === null
		        if (A === null)
		            return false;
		        if (O === A)// 这里重点：当 O 严格等于 A 时，返回 true
		            return true;
		        A = A.__proto__;
		    }
		}
		
		
		//for in 循环中的in判断的是对象的所有属性，包括自身的属性和通过原型链继承的属性
		//hasOwnProperty方法判断的是实例自身所有的属性，而不包括通过原型链继承的属性
		
		var carObj = {
			type: "smallCar",
			color: "red"
		}
		function Car(){
			
		}
		Car.prototype = carObj;
		var baoma = new Car();
		console.log(baoma.__proto__.__proto__ === Object.prototype);//true
		
		//js执行上下文
		//在全局状态下，普通变量或函数表达式（var f1 = function(){}）会被声明，并赋值undefined
		//this会被赋值，函数声明（function f1(){}）会被赋值
		//如果这段代码是函数体，那么在此基础上附加：参数的赋值，arguments的赋值，自由变量的取值作用域的确定
		/*
		例如:
		console.log(bianliang);//undefined
		var bianliang = 10;		
		
//		console.log(bianliang2);//没有声明的情况下直接报错
		*/
		/*
		console.log(hanshu);//函数体
		function hanshu(){
			
		}
		console.log(hanshu2);//undefined
		var hanshu2 = function(){
			
		}
		*/
//		在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。
//		因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。
		
		function Anime(){
			this.a = 1;
			console.log(111);
		}
		Anime();
		var lzsy = new Anime();//会执行console.log();语句
		
		
		
		console.log(newFunc); //undefined
		if(true){
			console.log(newFunc); //undefined
			var newFunc = function(){};
		}
		//if代码块虽然没有自己的上下文环境，但有自己的“领域”，执行if语句时才会表现
		console.log(newFunc2); //undefined
		if(true){
			console.log(newFunc2); //function newFunc2(){}
			function newFunc2(){};
		}
		
		(function(n){
			(function f2(){
				n++;
			})()
			function f1(){
				n++;
			}
			f1();
			console.log(n);
		})(5);
		
		
		//上下文环境栈：当执行全局代码的时候，把全局的上下文环境压入栈内并设置活跃，当执行到某个函数时，将该函数的上下文环境压入栈，
		//并设置活跃状态。函数执行完毕，销毁函数上下文环境，重新设置全局上下文环境为活跃状态。
		//函数的作用域在创建时就已经确定，而不是在调用时确定
		//自由变量：在A作用域内没有声明，却在A作用域内使用的变量
		//当要寻找作用域中没用定义的变量时，要从创建了当前作用域的作用域中找，而不是调用，即
		//当a函数中没有变量c时，会在创建了a函数（不是调用啊）的函数b内继续寻找变量c，若没有则继续从创建了函数b的作用域中继续寻找
		//这种链式结构也叫作用域链
		/* 星级1
		var a=2;
		var obj={
			a:20,
			bar:function(f){
				var a=15;
				console.log(this.a);//20
				f();
			}
		}
		alert(obj.a);//20
		obj.bar(
			function(){
				console.log(a);//a的值为2,
			}
		);
		*/
		/*
		 作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，
		 不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，
		 而作用域却是在函数创建时就确定了。所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。
		 * */
		
		
		var max = 10;
		var fn = function(x){
			if(x > max){
				console.log(x);
			}
		};//当该函数下紧跟着一个匿名函数，如果这里不加分号会直接报错
//		console.log(fn);
		(function(f){
			var max = 100;
			f(15);	
		})(fn);
		
		var myFuncObj = {
			a: 10,
			func: function(){
				var b = 20;
				return function(){
					b++;
					console.log(b);
				}
			}
		};
		var result = myFuncObj.func();
		result();
		console.log(Infinity);
		//const关键字可以自定义常量
		//注意：常量定义不能在IE中使用（没有作用），仅能应用于Firefox、Navigator。所以，不推荐在JavaScript中定义常量
		const MYBOOLEAN = true;
		//试图改变常量，但没有作用，且报了错
//		MYBOOLEAN = false;
		console.log(MYBOOLEAN);
//		function func4(){
//			return;
//		}
//		var a = func4();
//		console.log(a);//undefined
//		//undefined==null,undefined!==null
//		console.log(a == null);//true
//		console.log(undefined == null);//true
//		console.log(undefined!==null);//true
		var str3 = "abcdefghigk";
		console.log(str3.substring(1,-2));//a,不能接受负值，负值会被认为0，但是前后值所指的位置顺序无所谓，会自动转换
		console.log(typeof str3.slice(5,-8));//string虽然能接受负值，但是第一个数所指的位置必须在前面,否则为空字符串
		console.log(str3.slice(5,-8));//""输出空字符串
		
		
		//下面这几行仅仅是用来验证书本上的疑问，没有什么用
//		var a = 1234.5;
//		var b = "abc";
//		b = a;
//		console.log(b);//1234.5
		var arr = [1];

		if(1===true){
			console.log("1===true");
		}else{
			console.log("1!==true");
		}
		var str = "abc";
		console.log(str === "abc");//true
		console.log(0 == "0");//true
		console.log(0 == "");//true
		console.log(3>"2");//true
		//arr的constructor的prototype所指的对象是否在arr的原型链中
		console.log(arr instanceof arr.constructor);//true
		console.log(arr[0]);//1
		//删除了数组中的元素
		arr.length = 0;
		console.log(arr[0]);//undefined
		//void运算符计算表达式，然后放弃其值，返回undefined
		
		
		//在使用if else 等语句时，最好将几率大的条件放在前面，以提高效率
		
		//当页面加载完成后使用document.wirte();方法则会替换掉原来的页面内容，展示括号内的内容
//		window.onload = function(){
//			document.write(111);
//		}
		
		var x3 = "good!";
		var x = 3;
		var y = eval("x" + x);//获得字面的"x"和x变量的值组合后再转化为变量
		console.log(y);//good!
		
//		escape()函数是转义函数,它将参数转换为字符串,并以URL编码格式进行编码,在这种格式中,所有空格,标点,重音符号
//		以及其他非ASCII字符都用%xx十六进制序列编码代替,unescape()函数与escape函数的功能恰恰相反
		//eacape()和unescape()函数在处理非ASCII字符时会出错，他们不能对unicode字符进行编解码
		//所以不再推荐使用这两个函数进行转义和反向转义
		
//		encodeURI()和decodeURI()函数:
//		encodeURI()函数将文本字符串编码为一个有效的统一资源标识符,decodeURI函数作用与它正好相反
//		encodeURI()函数不对如下字符进行编码:
//		保留的字符               ; , / ? : @ & = + $
//		反向转义字符           英文字母   数字   - _ . ! ~  * ' (  )
//		井号		  #
//		另外要注意,encodeURI()函数单靠自身不能形成HTTP GET请求或POST请求,因为&,+,=都不会被编码,而这几个字符在
//		GET或POST请求中都被作为特殊字符对待.用户可以使用encodeURIComponent()函数对这些字符进行编码.
//		encodeURIComponent()函数可以转义出英文字母,数字,-,_,.,!,~,*,',(,)外的所有字符
//		技巧与提示:
//		如果要想服务器发送数据,那么最好使用encodeURIComponent()函数转移要发送的数据,特别是将用户输入的数据作为请求参数发送时.
//		因为用户输入的数据可能包含非法字符,例如&字符,该字符是用来分隔查询变量的,如果不加以转义,那么就会发生混乱.
		
		/*
		var obj = {
			a: 1,
			b: 2
		}
		console.log(obj["a"]);//1
		*/
		
//		var func = function(){
//			console.log(1);
//		}
//		func();
//		func = null;
//		func();//func is not a function


		//关于上下文环境保存变量的例子,星级1
		/*
		function createFunction(){
		    var result=new Array();
		    for(var i=0;i<10;i++){
		    	//每次循环都创建了一个新的上下文环境来保存每次不同的i
		    	//个人理解为：当调用函数后才会去创建上下文环境，并去寻找(在作用域链中寻找)，保存相应的变量
		        result[i]=function(m){
		            return function(){
		                return m;
		            };
		        }(i);
		    }
		    return result;
		}
 
		var arr = createFunction();
		for (var j = 0; j < arr.length; j++) {
		    console.log(arr[j]());//一次输出0-9
		}
		*/
		//关于执行函数前，先执行上下文环境的例子
		//在函数中执行上下文环境的时候，先对局部变量进行声明，并赋值为undefined，然后对arguments赋值，再对形参进行赋值
		//这样不会因为局部变量和形参同名，而导致undefined覆盖掉形参，也不会因为形参和arguments同名，而导致arguments覆盖掉形参
		//其实就不推荐形参定义的和局部变量，函数名或者其他JavaScript内建对象名或属性名同名，容易引起理解的混乱.
		/*
		var Y = 1;
		function setLocalVariable(){
			//调用函数时，一开始先执行上下文，确定了局部变量Y的存在并赋值为undefined
			console.log("局部变量Y:"+Y);
			var Y = 2;
			//如果没有var，而是直接Y=2,则第一句输出全局变量的Y的值
			console.log("局部变量Y:"+Y);
		}
		console.log("全局变量Y:"+Y);
		setLocalVariable();
		console.log("全局变量Y:"+Y);
		*/
		
		/*关于严格模式下，函数体内使用全局变量的例子
		"use strict";
		var Y = 2;
		function testStrict(){
			Y = 1;
			console.log(Y);//1,没报错
		}
		testStrict();
		*/
		/*
		for(var i=0;i<10;i++){
			setTimeout((function(e){
				return function(){
					//输出了0-9
					console.log(e);
				}
			})(i),1000);
		}
		*/
		function Cat(){
			this.name = "tom";
			var name = "jery";
			//和普通内部函数一样，当调用函数的时候会在作用域链中查找变量，并保存在上下文环境中,也能形成闭包
			//这里创建了匿名函数的是Cat函数，this.eat只是一个赋值过程，作用域链第二级为Cat，而不是创建的实例对象
			this.eat = function(){
				console.log(name);//jery
			}
		}
		Cat.prototype = {};
		var blackCat = new Cat();
		blackCat.eat();
		console.log(blackCat.__proto__.constructor.__proto__ === Function.prototype);//true
		
		console.log(blackCat.age);//不会报错，而是输出undefined
		
		function Animal(){
			
		}
		var animal = new Animal();
		Cat.prototype = animal;
		console.log(Cat.prototype.constructor === Animal);//true
		
		function Cat2(){
			
		}
		Cat2.prototype = new Cat();
		console.log(Cat2.prototype.__proto__ === Cat.prototype);//true
//		console.log(Cat2.prototype.__proto__);
//		console.log(Cat.prototype);
		
		console.log(Object.prototype.constructor === Object);//true
//		console.log(1,2);
		console.log(String.prototype.__proto__ === Object.prototype);//true
		console.log(typeof String);//function
		console.log(String.constructor === Function);//true
		console.log(Function.constructor === Function);//true
		//new关键字执行的过程
		/*
		new Animal("cat") = {
			//首先创建一个空对象
		    var obj = {};
			//然后让该对象继承于Animal.prototype(加入原型链)
		    obj.__proto__ = Animal.prototype;
			//调用Animal函数，this指向obj
		    var result = Animal.call(obj,"cat");
			//如果返回值为对象，则返回包括了Animal中定义的属性的对象，否则返回只有继承关系的空对象obj
		    return typeof result === 'object'? result : obj;
		}
		
		*/
		/*一个超类的例子
		Object.prototype.$super = function(){
			console.log("this is $super inner");
			var result;
			try{
				result = eval(this.constructor).prototype.constructor;
				result.apply(this,arguments);
			}catch(err){
				throw new Error("error!");
			}
			return result;
		}
		Object.prototype.func = function(){
			console.log("this is object func");
		}
		
		function Person2(){
			this.myName = arguments[0];
			this.myAge = arguments[1];
		}
		
		function Child(myName,myAge){
//			console.log(typeof this);
			this.$super(myName,myAge);
		}
		obj = {};
//		console.log(obj);
		obj.$super();
		Child.prototype = new Person2();
		
		var child1 = new Child("jack",18);
		child1.func();
		*/
//		console.log(str.substr(0,2));
		
		function Tool(){
			
		}
		Tool.i = 1;
		Tool.getData = function(){
			var data = this.i;
			console.log(arguments);
			return data;
		}
		console.log(Tool.getData());//1
		
		//重载在Java，c#等面向对象语言中表示方法名相同，但是方法的中的形参列表不同的多个方法
		//这些方法会根据调用时传递的不同参数列表调用不同的方法(参数数量，参数类型，参数顺序等方面不同)
		//注意：JavaScript不允许出现相同名称的方法，所以只能在方法的内部判断参数列表的长度，
		//值类型等来执行相应不同的代码，来达到类似的目的
		//例如：
		/*
		var testChongzai = function(){
			var len = arguments.length;
			if(len == 2){
				console.log("调用的是两个参数的方法");
			}else if(len == 3){
				console.log("调用的是三个参数的方法");
			}else{
				//当参数传递的数量不是定义好的两个数量，则说明调用的方法不存在于我们希望定义的几个重载方法中，则抛出异常，终止程序
				throw new Error("参数数量不对");
			}
		}
		*/
		//覆载即为子类定义一个与父类同名的方法，使调用时调用的为子类的方法而不是父类的方法的行为
		//例如：
		/*
			function Tool(){
				this.func = function(){
					console.log("this is Tool");
				}
			}
			function Shuazi(){
				this.func = function(){
					console.log("this is Shuazi");
				}
			}
			Shuazi.prototype = new Tool();
			var shuazi = new Shuazi();
			shuazi.func();//this is Shuazi
		*/
		//方法重载和方法覆载都被称为多态
		
		
		
		
//		function testArguments(a,b){
//			console.log(arguments);
//		}
//		testArguments(1);
		
		/*
		var obj8 = {a:8,b:"b8"};
		console.log(obj8);
		//下面这句语句没有效果，可能是JavaScript不允许Object.prototype被赋值为一个新的对象
		Object.prototype = obj8;
		Object.prototype.b = "Ob";
		Object.prototype.c = "oC";
		var obj9 = {a:9};
		console.log(obj8.__proto__ === Function.prototype.__proto__);//true
		console.log(obj9.__proto__ === obj8);//false
		console.log(Object.prototype.b);//Ob
//		console.log(typeof Object.prototype);//object
		var str = "abc";
		console.log(str.b);//Ob
		console.log(obj8.c);//oC
		*/
		
//		console.log(Object);//Object(){[native code]}
		
		function Book(name,author){
			this.name = name;
			this.author =author;
			this.type = "fs";
		}
		
		function FsBook(name,author){
			this.name = name;
			this.author = author;
		}
		var book1 = new Book("book1","jack");
		book1.type = "action";
		FsBook.prototype = book1;
		var book2 = new FsBook("book2","tom");
		console.log(book2.name);//book2
		console.log(book2.type);//action
		
		
		console.log(typeof Object.getPrototypeOf);//function
		
		console.log(Object.constructor);//Function(){[native code]}
		console.log(Object.prototype.constructor);//Object(){[native code]}
		
		//Object.propertyIsEnumerable(propertyName);
		//方法可以查看指定的属性是否存在及是否可枚举(即该属性为自定义的属性)，propertyName为字符串值，如果返回true
		//则说明属性存在并且可枚举，有些属性不可枚举，例如array类型值的length属性


		
		/*
		function testArgus(a){
			console.log(a);//undefined
		}
		//没有参数，在执行上下文环境时，参数的赋值就为undefined
		testArgus();
		*/
		var arr = new Array();
		console.log(typeof arr);//object
		console.log(arr instanceof Array);//true
		console.log(arr instanceof Object);//true
		console.log(arr.constructor.prototype === Array.prototype);//true
		
		console.log(arr.constructor.prototype === Object.prototype);//false
		
//		var newArray = [];
//		console.log(Object.prototype.toString.call(newArray));//[object Array]

//		var newArray = new Array(1,2,3);
//		newArray.length = 1;
//		console.log(newArray[1]);//undefined
		
//		var newArray = null;
//		console.log(newArray.toString());//报错
		/*
		var newArray = [1,2,3];
		var newArray2 = newArray.slice(1,2);//截取数组中的一段，并返回这一段为一个数组，不修改原数组,两个参数均为索引
		console.log(newArray2);//[2]
		console.log(newArray);//[1,2,3]
		var newArray3 = newArray.splice(1,2);//对原数组直接进行操作，返回被截断的数组，第一个参数为索引，第二个为数量
		console.log(newArray);[1]
		console.log(newArray3);[2,3]
		*/
		var newArray = [1,2,3];
		newArray["a"] = 4;
		newArray.push(5);
		console.log(newArray[3]);//5
		var newArray2 = new Array();
		newArray2["a"] = 1;
		newArray2["b"] = 2;
		newArray2.push(3);
		console.log(newArray2[0]);//3
		console.log(newArray2.length);//1
		console.log(newArray2.b);//2
		
		/*
		var newDate = new Date(2001,2,30);
		console.log(newDate.getTime());//985881600000,并没有管你设置的日期是否真实存在
		*/
		
		/*
		var dateStr = "Mon Aug 7 00:00:00 UTC+0800 1989";
		var newDate = new Date(dateStr);
		var newDate2 = Date.parse(dateStr);
		var newDate3 = new Date(dateStr);
		newDate3.setFullYear(2001);
		console.log(newDate.getFullYear());//1989,时间字符串能被转换成日期
		console.log(typeof newDate2);//number,使用静态方法parse得到的为时间戳
		console.log(newDate3.getFullYear());//2001
		*/
		
		/*
		var oneDay = new Date(70,0,2,0,0,0);
		console.log(oneDay.getUTCHours());//16
		oneDay.setUTCHours(0);
		oneDay.setUTCDate(2);
//		oneDay = oneDay.setUTCDate();
		console.log(oneDay.getTime());//86400000
		
		var newDay = new Date(2000,1,29);
		var nextDay = new Date(newDay.getTime() + oneDay.getTime());
		console.log(nextDay.toString());//2000 3 1
		console.log(newDay.getTime() + oneDay.getTime());//951840000000
		console.log(nextDay.getFullYear());//2000
		*/
		
		/*
		function testArgu(a,b){
			console.log(arguments);
			console.log(arguments.length);//2
			for(var i=0;i<arguments.length;i++){
				console.log(arguments[i]);//分别输出1，2
				
			}
		}
		testArgu(1,2);
		*/
		/*
		arguments.callee是当前正在执行的函数,例如下面这段代码会形成一个无限循环:
		function theFunction(){
			arguments.callee();
		}
		theFunction();
		*/
		/*
		oFunction.caller是对当前正在执行函数的调用者的引用(不是指this概念中的调用者，是另一个函数),例如下面这段代码会形成一个无限循环:
		function theFunction(){
			otherFunction();
		}
		function otherFunction(){
			otherFunction.caller();
		}
		theFunction();
		*/
		
		function showModalDialogFunc(){
			//将window对象通过参数传递到新页面，新页面就能使用此页面的函数和全局变量了
			window.showModalDialog("http://www.bilibili.com",window);//chrome会出现方法不存在的报错。360可以弹出
		}
		console.log(window.name);
		/*
		//当当前页面获得焦点时触发
		window.onpageshow = function(event){
			alert(event.persisted);//false
		}
		*/
		//加载新的HTML文档
//		location.assign("http://www.baidu.com");
		//获取浏览器所在操作系统名
		console.log(window.navigator.platform);//win32
		
		var newObj = {};
		var newArr = [];
		console.log(newObj.constructor.prototype === Object.prototype);//true
		console.log(newArr.constructor.prototype === Object.prototype);//false
		console.log(newObj.constructor.prototype === Object.getPrototypeOf(Array.prototype));//true
		console.log(newArr.constructor.prototype === Array.prototype);//true
		console.log(newObj.constructor.prototype === Array.prototype);//false
		
//		console.log(typeof newObj === 'object');
		//全局变量作为window对象的一个属性
		var quanjuVariable = 100;
		console.log(window.quanjuVariable);
		
//		import foo from "../../js/myJS"
//		console.log(foo);
		
	</script>
	<script type="application/javascript;version = 1.6">
		var arr = [1,2,3,4];
		//与for in不同，for each...in遍历对象或数组的属性值，而不是属性名
		//for each...in语句作为E4X语言扩展的一部分引入，是JavaScript1.6引入的信誉发，仅能在Firfox 2以上版本
		//的浏览器中使用。对于应用JavaScript1.6及更高版本的语法，必须在script标签的type属性中声明版本号（如上script标签）
		for each(var item in arr){
			console.log(item);
		}
		
		
		

	</script>
	<script type="application/javascript;version = 1.7">
//		let语句是JavaScript1.7新增的,经适用于Firefox2.0或更高版本浏览器
//		let与var定义的变量区别在于作用域不同,let在他所在的函数块,例如for循环开始用let定义了一个变量,它就不能在循环外使用
		for(let testLet=0;testLet<2;testLet++){
			console.log(testLet);//0  1
		}
//		console.log(testLet);//undefined
		if(1){
			let testLet2 = 1;
			console.log(testLet2);//1
		}
//		console.log(testLet2);//undefined
	</script>
</html>
